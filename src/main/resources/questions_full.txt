[
  { "theme": "Infastucture",
    "description": "Как в windows, linux проверить версию Java, версию Maven?",
    "answer": "В консоли выполнить: java -version, mvn -version"
  },

  { "theme": "Infastucture",
    "description": "Можно ли в одной операционной системе иметь одновременно несколько разных версий Java?",
    "answer": "Можно"
  },

  { "theme": "Infastucture",
    "description": "Как переключаться с одной версии на другую?",
    "answer": "В windows - для переменной окружения среды JAVA_HOME указать расположение нужной версии Java, В Linux в консоли выполнить - update-alternatives --config java и выбрать нужную версию"
  },

  { "theme": "Infastucture",
    "description": "В чем отличие файловой системы windows от linux? Какие папки есть в корне Linux?",
    "answer": "Windows использует FAT и NTFS в качестве файловых систем, а Linux использует множество файловых систем. В отличие от Windows, Linux загружается с сетевого диска. В отличие от Windows, в Linux все является либо файлом, либо процессом. dev, home, etc, usr..."
  },

  { "theme": "Infastucture",
    "description": "Назовите некоторые уровни стека сетевых протоколов OSI",
    "answer": "Прикладной уровень - Уровень представления - Сеансовый уровень - Транспортный уровень - Сетевой уровень - Канальный уровень - Физический уровень"
  },

  { "theme": "Infastucture",
    "description": "В чем отличия протоколов TCP и UDP?",
    "answer": "TCP гарантирует доставку пакетов данных в неизменных виде, последовательности и без потерь, UDP ничего не гарантирует. TCP нумерует пакеты при передаче, а UDP нет..."
  },

  { "theme": "Infastucture",
    "description": "Что такое URI, URN, URL?",
    "answer": "URL - Uniform Resource Locator (унифицированный определитель местонахождения ресурса); URN - Unifrorm Resource Name (унифицированное имя ресурса); URI - Uniform Resource Identifier (унифицированный идентификатор ресурса)"
  },

  { "theme": "Infastucture",
    "description": "Если мы с помощью мавен подключаем библиотеку, которая содержит в себе набор зависимостей - как можно сделать так, чтобы с библиотекой подтянулись не все дополнительные зависимости, а некоторые были исключены?",
    "answer": "С помощью <exclude>"
  },

  { "theme": "Infastucture",
    "description": "При подключении зависимости мы можем указывать <scope> - для чего он используется? Что означает <scope>provided</scope>",
    "answer": "provided - закисимость не нужно упаковывать в итоговый архив, так как она предоставляется сервером приложений"
  },

  { "theme": "Infastucture",
    "description": "Перечислите основные фазы мавен",
    "answer": "compile - компилирование проекта; test - тестирование с помощью JUnit тестов; package - создание jar файла или war, ear в зависимости от типа проекта; integration-test - запуск интеграционных тестов; install - копирование jar (war, ear) в локальный репозиторий; clean - удаление всех созданных в процессе сборки артефактов: .class, .jar и др. файлов. В простейшем случае результат — просто удаление каталога target; site - предназначена для создания документации; deploy - публикация файла в удалённый репозиторий."
  },

  { "theme": "Infastucture",
    "description": "Как можно пропустить тесты при сборке проекта мавеном?",
    "answer": "-Dmaven.test.skip=true"
  },

  { "theme": "Infastucture",
    "description": "Как можно с помощью мавена через командную строку запустить spring-boot проект без тестов?",
    "answer": "-DskipTests"
  },

  { "theme": "Cuncurrency",
    "description": "synchronized, wait/notify/notifyAll",
    "answer": "synchronized — ключевое слово, обозначающее скоуп критической секции. wait() — ожидание треда до тех пор, пока он не будет разбужен другим тредом через notify/notifyAll. У wait() есть перегруженные версии с таймаутами. notify() — будит один из ожидающих тредов, но Важно! — лок на объекте не отпускает. notifyAll() — будут разбужены все треды в wait-set"
  },

  { "theme": "Cuncurrency",
    "description": "Deadlocks, условия наступления, как избежать?",
    "answer": "Условия наступления — эксклюзивность доступа к ресурсам, наличие циклов в графе ожиданий ресурсов, отсуствие таймаутов на ожидание. Как избежать — задать порядок доступа к ресурсам. Всегда обращение в порядке либо Thread1->Thread2, либо Thread2->Thread1"
  },


  { "theme": "Cuncurrency",
    "description": "В каких состояниях может находиться поток?",
    "answer": "NEW, RUNNABLE, BLOCKED(monitor lock), WAITING(Thread.join), TERMINATED"
  },

  { "theme": "Cuncurrency",
    "description": "Как создать и запустить поток?",
    "answer": "extends Thread, переопределить метод Run, и вызвать new MyThread.start(). Имплементировать Runnable, переопределить метод Run и аналогично. Использоветь ExecutorService: ExecutorService executor = Executors.newFixedThreadPool(10);...executor.submit(() -> {new Task();}); CompletableFuture.supplyAsync(() -> 'Hello');"
  },

  { "theme": "Cuncurrency",
    "description": "В чем отличия runnable от callable? Что возвращает callable?",
    "answer": "Callable возвращает объект Future, а Runnable ничего не возвращает"
  },

  { "theme": "Cuncurrency",
    "description": "Для чего используется ключевое слово volatile?",
    "answer": "Ключевое слово volatile устанавливает отношение happens-before над операциями записи-чтения на поле (на уровне памяти процесса - не позволяет хранить переменные, помеченные volatile в локальных кэшах процесса)"
  },

  { "theme": "Cuncurrency",
    "description": "Что такое  happens-before",
    "answer": "Happens-before -Это гарантии JVM что определенные операции выполнятся в строгом порядке и все последующие операции будут выполнены только после выполнения предыдущих."
  },

  { "theme": "Cuncurrency",
    "description": "Что такое ThreadLocal переменная?",
    "answer": "Переменная, которая доступна только для потока, в котором она хранится"
  },

  { "theme": "Cuncurrency",
    "description": "Для чего используется класс Executors? В чем отличие Executor от ExecutorService",
    "answer": "Executor — простой интерфейс, содержащий метод execute() для запуска задачи, заданной запускаемым объектом Runnable. ExecutorService представляет собой суб-интерфейс Executor, который добавляет функциональность для управления жизненным циклом потоков. может принимать как выполняемый (Runnable), так и вызываемый (Callable) объект."
  },

  { "theme": "Cuncurrency",
    "description": "Что такое пул потоков? Для чего используется? Какие в Java есть пулы потоков?",
    "answer": "FixedThreadPool  пул потоков с фиксированным количеством повторно используемых потоков. CachedThreadPool пул потоков, который создает новые потоки. Он также повторно использует ранее созданные потоки, когда они доступны. ScheduledThreadPool пул потоков, который планирует выполнение после определенной задержки или периода времени. SingleThreadExecutor пул потоков с одним потоком, который выполняет все задачи ForkJoinPool"
  },

  { "theme": "Cuncurrency",
    "description": "Какой пул потоков используется в параллельных стримах? Как он работает?",
    "answer": "ForkJoinPool рекурсивно разбивает задачу на более мелкие независимые подзадачи, пока они не станут достаточно простыми для асинхронного выполнения, после чего каждая задача выполняется. После этого начинается часть “соединение” , в которой результаты всех подзадач рекурсивно объединяются в один результат, или в случае задачи, которая возвращает void, программа просто ждет, пока не будет выполнена каждая подзадача."
  },

  { "theme": "Cuncurrency",
    "description": "Java Util Concurrent - какие есть объекты синхронизации? Для чего они применяются?",
    "answer": "Semaphore, CountDownLatch, CyclicBarrier, Exchanger, Phaser <href https://habr.com/ru/post/277669 />"

  },

  { "theme": "Cuncurrency",
    "description": "Lock vs ReadWriteLock",
    "answer": ""

  },

  { "theme": "Cuncurrency",
    "description": "Что такое атомики? Как работает механизм CAS(Compare And Swap)?",
    "answer": "AtomicBoolean (Integer,Long,Reference) (содержат compareAndSet(), принимающий 2 арг-та : текущее и новое значения. Устанавливает объекту новое значение, если текущее равно предпполагаемому, и возвращает true. Если текущее значение изменилось, то false и новое значение не будет установлено. Также имеют getAndSet(), устанавливающий новое значение и возвращющий старое. AInteger и ALong имеют методы инкремента/декремента/добавления нового значения.) AIntegerArray, ALongArray, AReferenceArray (Atomic-классы для массивов integer, long и ссылок на объекты) AIntegerFieldUpdater, ALongFieldUpdater, AReferenceFieldUpdater (Для обновления полей по их именам с использованием reflection. Смещения полей для CAS операций определяется в конструкторе и кэшируются.) AStampedReference, AMarkableReference"
  },

  {
    "theme": "Java Core",
    "description": "Что такое наследование, почему множественное наследование запрещено",
    "answer": "Наследование - это возможность для класса потомка забрать для себя поведение класса родителя, и при необходимости переопределить его. Множественное наследование запрещено из-за ромбовидной зависимости (если оба родителя реализуют один и тот же метод разными способами - JVM не поймет какой использовать)"
  },
  {
    "theme": "Java Core",
    "description": "Ключевое слово Final - где и что дает",
    "answer": "Класс нельзя наследовать, метод нельзя переопределять, переменной нельзя присваивать новое значение (менять ссылку), переменную метода нельзя менять"
  },
  {
    "theme": "Java Core",
    "description": "Что будет выведено в консоль, если в статическом методе выполнить System.out.println нестатической переменной класса? Как можно эту переменную вывести в консоль? ",
    "answer": "Нельзя обращаться из статических методов к нестатическим переменным."
  },
  {
    "theme": "Java Core",
    "description": "Что такое string-pool? В чем отличие cоздания строки через new от литерала? Как строку, созданную через new поместить в пул?",
    "answer": "String pool - область памяти в Heap, где хранятся все неинтернированные строки (объявленные через 'строка'), таким образом Java не создает новые строки, а использует те, которые хранятся в Pool. Можно создать объект new String('string').intern(), чтобы поместить значение в пул строк"
  },
  {
    "theme": "Java Core",
    "description": "Что такое утечка памяти? Как в Java сделать утечку памяти?",
    "answer": "Утечка памяти — это ситуация, когда в куче присутствуют объекты, которые больше не используются, но сборщик мусора не может удалить их из памяти и, таким образом, они сохраняются там без необходимости. Утечка памяти плоха тем, что она блокирует ресурсы памяти и со временем снижает производительность системы. Для реализации утечки памяти - нужно создавать объекты, на которые всегда будет ссылаться root объект (незакрытые потоки ввода/вывода к примеру)"
  },
  {
    "theme": "Java Core",
    "description": "Что такое classloader, и их иерархия. Этапы загрузки класса класслоадером. Из за чего может возникать NoClassDefFoundError, NoSuchMethodError?",
    "answer": "Иерархия classloader'ов\nBootstrap, System, Application. Загрузка - низший в иерархии ищет в своих кэшах класс, проверяя не загружал ли он его ранее, если нужный класс не найден - делегирует загрузку своему родителю и так вверх по иерархии класслоадеров. Если самый верхний в иерархии класслоадер не нашел класс в своих кэшах - он пытается загрузить его. Если загрузить не удалось - он делегирует это дочернему класслоадеру, и так вниз по иерархии. NoClassDefFoundError может возникнуть, если нужной библиотеки с этим классом нет в classpath. NoSuchMethodError может возникнуть из-за несовместимости ваших библиотек, если зависимая библиотека A вызывает метод из старой версии библиотеки B, но в classpath есть более новая версия библиотеки B, c другой сигнатурой этого метода"
  },
  {
    "theme": "Java Core",
    "description": "Что такое врапперы?  Для каких классов они существуют и для чего используются? Как преобразовывать примитив в враппер и обратно?",
    "answer": "Враппер - обертки над примитивами. Например Integer == враппер над int."
  },
  {
    "theme": "Java Core",
    "description": "В чем разница между интерфейсом и абстрактным классом?",
    "answer": "Интерфейс есть средство наследования API, абстрактный класс — средство наследования реализации. Через интерфейсы возможно осуществлять множественное наследование, абстрактный класс можно наследовать в одном экземпляре.В интерфейсе нет возможности определить поля и конструкторы"
  },
  {
    "theme": "Java Core",
    "description": "1. Что такое переопределение методов? 2. Какие методы нельзя переопределить? 3. Если в классе-наследнике переопределить метод родителя, то как Java понимает что вызвать нужно именно его, ведь на объекты обычно ссылаются по переменным типа родителя или интерфейса?",
    "answer": "С помощью  таблицы виртуальных методов (VMT). Таблица методов класса после загрузки и динамического связывания класса в конечном счете содержит ссылки на методы данного класса. Если метод определен в данном классе, это будет ссылка на метод данного класса. Если метод определен в суперклассе, это будет ссылка на метод суперкласса."
  },
  {
    "theme": "Java Core",
    "description": "Что такое статическое и динамическое связывание? Приведите примеры?",
    "answer": ""
  },

  {
    "theme": "Java Core",
    "description": "Какие в Java есть типы ссылок и для чего они используются?",
    "answer": "Сильная ссылка -STRONG - Объект в куче не удаляется сборщиком мусора, пока на него указывает сильная ссылка или если он явно доступен через цепочку сильных ссылок. Слабая ссылка-WEAK - слабая ссылка на объект из кучи, скорее всего, не сохранится после следующего процесса сборки мусора. Хорошим вариантом использования слабых ссылок являются сценарии кеширования.Мягкая ссылка -SOFT -объекты, на которые есть такие ссылки будут собираться сборщиком мусора только тогда, когдаприложению не хватает памяти. Java гарантирует, что все объекты, на которые имеются мягкие ссылки, будут очищены до того, как будет выдано исключение OutOfMemoryError. Фантомная ссылка -FANTOM - Используется для планирования посмертных действий по очистке, поскольку мы точно знаем, что объекты больше не живы. "
  },
  {
    "theme": "Java Core",
    "description": "Что такое иммутабельный объект? Есть ли в Java такие классы? Как сделать чтобы все объекты класса были иммутабельными? ",
    "answer": "Объект, который нельзя изменять. Т.е. он final, у него отсутствую setterы, а также ограничены getterы. Пример класс String"
  },
  {
    "theme": "Java Core",
    "description": "Контракт equals/hashcode",
    "answer": "Рефлексивность: для любого заданного значения x, выражение x.equals(x) должно возвращать true. Заданного — имеется в виду такого, что x != null; Симметричность: для любых заданных значений x и y, x.equals(y) должно возвращать true только в том случае, когда y.equals(x) возвращает true. Транзитивность: для любых заданных значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, x.equals(z) должно вернуть значение true. Согласованность: для любых заданных значений x и y повторный вызов x.equals(y) будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами. Сравнение null: для любого заданного значения x вызов x.equals(null) должен возвращать false."
  },
  {
    "theme": "Java Core",

    "description": "Для чего в Java используются дженерики? Как реализован механизм дженериков?",
    "answer": "С помощью дженериков можно создать один класс, а потом на основе него — несколько объектов этого класса для разных типов. Не понадобится дублировать код и усложнять программу. Поэтому дженерики лучше и удобнее, чем проверка типа прямо в коде — тогда для каждого типа данных понадобился бы свой класс."
  },
  {
    "theme": "Java Core",
    "description": "Ковариантность/контравариантность. Принцип PECS",
    "answer": "Ковариантность — List<? extends T>, если B extends T, то и List<B> extends List<T>\nКонтраваринтность — List<? super T>, если B super T, то и List<B> super List<T>\nPECS — Producer-Extends-Consumer-Super, метод отдаёт ковариантный тип, принимает контравариантный"
  },
  {
    "theme": "Java Core",
    "description": "Есть класс Б, который наследуется от класса А. В обоих классах есть статические и нестатические блоки инициализации. Опишите порядок создания объекта класса Б - в каком порядке отработают конструкторы/блоки инициализации? ",
    "answer": "Статические поля класса Parent; Статический блок инициализации класса Parent; Статические поля класса Сhild; Статический блок инициализации класса Child; Нестатические поля класса Parent; Нестатический блок инициализации класса Parent;"
  },
  {
    "theme": "Java Core",
    "description": "Связи между объектами (ассоциация, композиция, агрегация) - кратко и с примерами.",
    "answer": "Композиция -это тип отношений “принадлежит”. Это означает, что один из объектов является логически более крупной структурой, которая содержит другой объект. Другими словами, это часть или член другого объекта. Агрегация также является отношением “есть-есть”. Что отличает его от композиции, так это то, что он не предполагает владения. В результате жизненный цикл объектов не привязан: каждый из них может существовать независимо друг от друга. Ассоциация-это самая слабая связь между этими тремя. Это не отношение “имеет-а” , ни один из объектов не является частью или членом другого.Ассоциация означает только то, что объекты “знают” друг друга. "
  },
  {
    "theme": "Java Core",
    "description": "Блок try/catch/finally. Выполнится ли finally, если в блоке catch выполнить return?",
    "answer": "выполнится"
  },
  {
    "theme": "Java Core",
    "description": "Что такое Stream? Какие есть типы операций? Для чего используется операция reduce? В чем отличие map от flatmap? Можно ли переиспользовать один и тот же стрим?",
    "answer": "Стримы передают элементы из источника (какой-либо структуры данных) через конвейер операций и возвращают некоторое значение, не модифицируя источник. Есть промежуточные и терминальные операции. Стримы ленивые, т.е. без терминальной операции - промежуточные операции даже не начнут выполняться. Reduce - для операций над всеми элементами коллекции (например если надо сложить все элементы). FlatMap - преобразует вложенные в коллекцию объекты, а мар - только элементы самой коллекции. Переиспользовать стрим нельзя. Он живет один раз до выполнения терминальной операции"
  },
  {
    "theme": "Java Core",
    "description": "Допустим у нас есть список объектов \"Заказ\", в каждом заказе есть \"Корзина\", в каждой корзине есть список товаров, у товара есть цена. Как с помощью стримов посчитать сумму всех товаров во всех заказах? Как можно исключить из стрима заказы, у которых в корзине всего один товар?",
    "answer": ""
  },
  {
    "theme": "Java Core",
    "description": "Что такое \"ссылка на метод\"? Что такое лфмбда-функция? Что такое функциональный интерфейс? Может ли функциональный интерфейс содержать дефолтные методы?",
    "answer": ""
  },
  {
    "theme": "Java Core",
    "description": "Для чего используется Optional? Допустим, у нас есть сущность Customer, у которого есть поле address, у адреса есть поле регион, у региона есть название. Как с помощью Optional получить название региона если оно существует - в противном случае выбросить IllegalArgumentException?",
    "answer": "Optional.ofNullable(Customer).map(Address::getAddress).map(Region::getRegion).map(Name::getName).orElseThrow(Exception::new)"
  },
  {
    "theme": "Java Core",
    "description": "Модель памяти Java. Какие есть разделы, что где хранится.",
    "answer": "Heap - это основной сегмент памяти, где хранятся объекты. Он делится на два подсегмента: Old Generation и New Generation. New Generationделится на подсегменты: Eden и два сегмента Survivor. Non-heap подразделяется на: Permanent Generation и Code Cache. Permanent Generation содержит набор метаинформации о классах. В Java 8 PermGen заменён на Metaspace - его динамически изменяемый по размеру аналог, именно здесь живут статические поля. Stack- содержит: Примитивные типы, ссылки на другие объекты. Когда метод завершает работу, блок перестаёт использоваться и освобождается. Размер стековой память намного меньше объёма памяти в куче"
  },
  {
    "theme": "Java Core",
    "description": "Что такое сборка мусора? В каких регионах памяти она происходит? Что такое \"малая\" и \"большая\" сборка? Что такое ситуация STW(stop the world)?",
    "answer": ""
  },
  {
    "theme": "Java Core",
    "description": "Какие объекты считаются мусором? Что такое корни при сборке мусора?",
    "answer": "Мертвые объекты -для целей малой сборки мусора объект считается мертвым и подлежащим утилизации, если до него невозможно добраться по ссылкам ни из объектов старшего поколения, ни из так называемых корней (roots), к каковым относятся ссылки из стеков потоков, статические члены классов и т. п."
  },
  {
    "theme": "Java Core",
    "description": "Какие есть виды сборщиков мусора? Краткое описание каждого сборщика.",
    "answer": "Serial (последовательный). Parallel (параллельный). Concurrent Mark Sweep(CMS)\nGarbage-First (G1)"
  },
  {
    "theme": "Java Core",
    "description": "В чем отличие Java IO от NIO?",
    "answer": "Это про потоки ввода-вывода. Java IO является потокоориентированным, а Java NIO – буфер-ориентированным. IO блокирует текущий поток исполнения, а NIO не блокирует"
  },
  {
    "theme": "Java Core",
    "description": "try with resources. Для каких источников данных можно использовать эту конструкцию?",
    "answer": "Только для тех, которые имплементируют Autocloseable"
  },
  {
    "theme": "Java Core",
    "description": "Что такое исключения? Иерархия исключений. Какие исключения нужно указывать в декларации методов а какие нет и почему? Checked - Unchecked исключения",
    "answer": "Trowable -> Errors & Exceptions. Exceptions -> Checked && Unchecked (Runtime). Проверяемые исключения обязательно обрабатывать, непроверямые необязетально но можно."
  },
  {
    "theme": "Java Core",
    "description": "Что такое анонимный класс?",
    "answer": "Анонимные классы - это классы, что не имеют имени и их создание происходит в момент инициализации объекта. например когда мы в Thread указываем new Runnable и переопределяем у него метод run на лету"
  },

  {
    "theme": "Collections",
    "description": "Иерархия коллекций. Почему Map находится в другом пакете?",
    "answer": "<href https://habr.com/ru/post/237043 />"
  },
  {
    "theme": "Collections",

    "description": "Устройство и различия ArrayList, LinkedList. Когда следует использовать.",
    "answer": "Если нужно быстро искать элементы по индексу - ArrayList, если быстро вставлять элементы внутрь массива - LinkedList"
  },
  {
    "theme": "Collections",

    "description": "Устройство HashMap, HashSet. Когда следует использовать. equals/hashcode для Map, Set. Что такое коллизия? Если все элементы попали в один бакет - кок они в нем будут храниться? \nСложность поиска элемента в HashMap: 1 - когда нет коллизий, 2 - когда 5 элементов в коллизии в одном бакете, 3 - когда 100 элементов в коллизии в одном бакете",
    "answer": "Сложность поиска: 1 - O(1), 2 - O(n), 3 - O(log n)"
  },
  {
    "theme": "Collections",
    "description": "Итератор по коллекции - как получить для коллекции, для чего используется. Можно ли с помощью итератора передвигаться взад-вперед по коллекции?",
    "answer": "Может только один раз проходить по коллекции. Для прохождения в двух направлениях есть ListIterator. Если в foreach цикле структурно модифицировать коллекцию, при последующем обращению к элементу (неявно через итератор) получим ConcurrentModificationException (fail-fast). hasNext(), next() — основные методы"
  },
  {
    "theme": "Collections",
    "description": "Отличия LinkedHashMap от TreeMap, для чего используются?",
    "answer": "LinkedHashMap позволяет сохранять порядок вставки пар key-value в Map. TreeMap  - в структуре сбалансированное красно-черное дерево, позволяет возвращать из него элементы, больше (меньше) указанного, либо range элементов, находящийся в определенных границах"
  },
  {
    "theme": "Collections",
    "description": "IdentityHashMap — когда используется",
    "answer": "IdentityHashMap — используется, только если нужно проверять идентичность двух ссылок, а не эквивалентность двух объектов по ним."
  },
  {
    "theme": "Collections",
    "description": "Могут ли HashMap и TreeMap хранить null  в качестве ключа?",
    "answer": "HashMap  да, TreeMap  нет"
  },
  {
    "theme": "Collections",
    "description": "Как можно массив преобразовать в List и после этого добавить в него 5 новых элементов?",
    "answer": "Неправильный ответ - с помощью Arrays.asList(), т.к. это возвращает неизменяемый лист и добавление в него невозможно"
  },
  {
    "theme": "Collections",
    "description": "Что такое FIFO и LIFO? Какие коллекции реализуют?",
    "answer": "First In - First Out\nLast in - First Out\nQueue — коллекция, предоставляющая возможности упорядочения элементов в порядке вставки согласно принципу FIFO.\nDeque — коллекция, предоставляющая возможность вставки значений в начала и в конец, позволяющая организовать очереди по принципам FIFO/LIFO.  \nStack - LIFO"
  },
  {
    "theme": "Collections",
    "description": "Что такое Comparator? Когда используется Comparator а когда Comparable?",
    "answer": ""
  },
  {
    "theme": "Collections",
    "description": "Какие потокобезопасные коллекции вы знаете?",
    "answer": "CopyOnWriteArrayList\nCopyOnWriteArraySet\nConcurrentHashMap\nConcurrentSkipListMap\n......"
  },
  {
    "theme": "Collections",
    "description": "Отличия Hashtable от ConcurrentHashMap",
    "answer": "Hashtable  - legacy, thread safe, методы синхронизированы, поэтому работа с Hashtable (обращение, удаление, добавление) в целом накладнее"
  },
  {
    "theme": "JDBC, ORM",
    "description": "С помощью чего Java приложение подключается к базе данных? Если в приложении есть несколько различных драйверов баз данных - как Java выбирает нужный при подключении к БД? Что такое DriverManager?",
    "answer": ""
  },
  {
    "theme": "JDBC, ORM",
    "description": "Чем отличаются Statement/PreparedStatement/CallableStatement?",
    "answer": "Statement – SQL-выражение, подготовленное к выполнению в рамках определенной JDBC-сессии. Выполняется методом execute для обычного выражения, executeUpdate для модифицирующего, executeBatch для пакетного. PreparedStatement – предскомпилированная версия Statement, его наследник. Эффективнее выполняет одно и то же выражение множество раз. Входные параметры объявляются в SQL-выражении символом ?, следом сеттерами задаются их типы и значения. CallableStatement – для вызова хранимых процедур."
  },
  {
    "theme": "JDBC, ORM",
    "description": "Шаги подключения приложения к БД через JDBC и совершения запроса",
    "answer": "Регистрация драйвера: Class.forName(\"oracle.jdbc.driver.OracleDriver\")\nСоздание соединения с БД Connection con=DriverManager.getConnection\nПодготовка запроса con.createStatement()\nВыполнение запроса stmt.executeQuery\nЗакрытие соединения con.close()"
  },
  {
    "theme": "JDBC, ORM",
    "description": "Какие есть типы ResultSet?",
    "answer": "ResultSet.TYPE_Forward_ONLY - можно считывать только в одном направлении\nResultSet.TYPE_SCROLL_INSENSITIVE\t - можно считывать в обоих направлениях, если в этот момент кто-то другой меняет данные в БД - сет этого не отобразит\nResultSet.TYPE_SCROLL_SENSITIVE - можно считывать в обоих направлениях, при этом сет чуствителен к изменениям, которые кто-то делает с БД\n"
  },
  {
    "theme": "JDBC, ORM",
    "description": "Можно ли как-то выполнять запросы не по одному, а пачками?",
    "answer": "Можно собирать их  в батчи с помощью stmt.addBatch(...)"
  },
  {
    "theme": "JDBC, ORM",
    "description": "Что такое JPA и в чем его отличие от Hibernate?",
    "answer": "JPA (Java Persistence API) это спецификация Java EE и Java SE, описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде.\nJPA только описывает правила и API, а Hibernate реализует эти описания"
  },
  {
    "theme": "JDBC, ORM",
    "description": "Что такое Entity",
    "answer": "Entity это легковесный хранимый объект бизнес логики (persistent domain object), помеченный нужными аннотациями"
  },
  {
    "theme": "JDBC, ORM",
    "description": " Может ли Entity класс наследоваться от не Entity классов\nМожет ли Entity класс наследоваться от других Entity классов\nМожет ли не Entity класс наследоваться от Entity класса\nМожет ли Entity быть абстрактным классом",
    "answer": "Все можно!"
  },
  {
    "theme": "JDBC, ORM",
    "description": "Требования JPA к Entity классам",
    "answer": "1) Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA, 2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами), 3) Entity класс должен быть классом верхнего уровня (top-level class), 4) Entity класс не может быть enum или интерфейсом, 5) Entity класс не может быть финальным классом (final class), 6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables), 7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс, 8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе), 9) Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных,"
  },
  {
    "theme": "JDBC, ORM",
    "description": " Какие типы данных можно использовать в атрибутах, входящих в первичный ключ Entity класса (составной или простой)",
    "answer": "1. примитивные типы и их обертки Java, 2. строки. 3. BigDecimal и BigInteger, 4. java.util.Date и java.sql.Date,"
  },
  {
    "theme": "JDBC, ORM",
    "description": " Что такое встраиваемый (Embeddable) класс?",
    "answer": "Встраиваемый (Embeddable) класс это класс который не используется сам по себе, только как часть одного или нескольких Entity классов. Entity класс могут содержать как одиночные встраиваемые классы, так и коллекции таких классов."
  },
  {
    "theme": "JDBC, ORM",
    "description": "Типы связей (relationship) между Entity",
    "answer": "1. OneToOne (связь один к одному, то есть один объект Entity может связан не больше чем с один объектом другого Entity ), 2. OneToMany (связь один ко многим, один объект Entity может быть связан с целой коллекцией других Entity), 3. ManyToOne (связь многие к одному, обратная связь для OneToMany), 4. ManyToMany (связь многие ко многим) Каждую из которых можно разделить ещё на два вида: 1. Bidirectional 2. Unidirectional"
  },
  {
    "theme": "JDBC, ORM",
    "description": "В каких состояниях может находиться сущность, которая управляется Hibernate?",
    "answer": "1) new — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных, 2) managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи, 3) detached — объект был создан, но не управляется (или больше не управляется) JPA, 4) removed — объект создан, управляется JPA, но будет удален после commit'a транзакции."
  },
  {
    "theme": "JDBC, ORM",
    "description": "Какие уровни кэшей имеет Hibernate и что в них кэшируется?",
    "answer": "3 уровня кэшей - транзакции, энтити-менеджера, запросов"
  },
  {
    "theme": "JDBC, ORM",
    "description": "Что такое JPQL (Java Persistence query language) и чем он отличается от SQL?",
    "answer": ""
  },
  {
    "theme": "JDBC, ORM",
    "description": "N+1 проблема, как решается",
    "answer": ""
  },
  {
    "theme": "JDBC, ORM",
    "description": "Когда возникает LazyInitializationException?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "В чем заключается суть Dependency Injection? Каковы его преимущества? IOC",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Что такое application context?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Жизненный цикл контейнера и бинов в нем. Допустим: написал конфигурацию для спринга, запустил приложение - что происходит дальше",
    "answer": "Контейнер создается при запуске приложения. Контейнер считывает конфигурационные данные. Из конфигурационных данных создается описание бинов. BeanFactoryPostProcessors обрабатывают описание бина. Контейнер создает бины используя их описание. Бины инициализируются — значения свойств и зависимости внедряются в бин. nBeanPostProcessor запускают методы обратного вызова(callback methods). Приложение запущено и работает. Инициализируется закрытие приложения. Контейнер закрывается\nВызываются callback methods"
  },
  {
    "theme": "Spring",
    "description": "Какими способами можно конфигурировать бины и контекст спринга?",
    "answer": "xml, java config, groovy..."
  },
  {
    "theme": "Spring",
    "description": "Что такое стереотипы(аннотации)? В чем отличия аннотации Service от Component, Bean?",
    "answer": "Стереотипы — это аннотации, обозначающие специальную функциональность. Все стереотипы включают в себя аннотацию @Component."
  },
  {
    "theme": "Spring",
    "description": "Области видимости бина. Видимость по умолчанию.",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Что такое BeanPostProcessor и чем он отличается от BeanFactoryPostProcessor?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Для чего используются @PreDestroy методы? Когда он может не выполниться?",
    "answer": "Такие методы выполняются только для бинов-синглтонов"
  },
  {
    "theme": "Spring",
    "description": "Что такое LookUp метод? Как его правильно сделать?",
    "answer": "Это один из способов внедрения зависимостей. Каждый раз, когда сервису требуется зависимость - он производит ее поиск в контексте. Для этого в сервисе должен быть абстрактный метод поиска нужной зависимости, этот метод нужно реализовать в конфигурации при декларации бина - в реализации метода нужно возвращать искомую зависимость."
  },
  {
    "theme": "Spring",
    "description": "Куда можно устанавливать аннотацию @Autowired и в чем отличие между способами?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Для чего используются аннотации @Qualifier, @Primary? Приведите примеры",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Что такое прокси-объекты и какие типы прокси-объектов может создавать Spring?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Что такое DispatcherServlet, когда используется? Что происходит с запросом, когда он попадает в спринг-приложение?",
    "answer": "Запрос приходит в DispatcherServlet\nDispatcherServlet отправляет запрос на один из контроллеров, основываясь на URL из запроса. Контроллер обрабатывает запрос, делегирует выполнение бизнес-логике бизнес-слою (как правило это классы с аннотацией @Service), и создает модель с данными, которую и отправляет обратно в DispatcherServlet. DispatcherServlet отправляет модель на фронт для вью, основываясь на интерфейсе ViewResolver(подробнее об этом ниже)"
  },
  {
    "theme": "Spring",
    "description": "Для чего используются аннотации @GetMapping, @PostMapping, @DeleteMapping, приведите пример",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "В чем разница между @Controller и @RestController",
    "answer": "У @RestController есть ResponseBody"
  },
  {
    "theme": "Spring",
    "description": "Как можно передавать параметры в рест-метод с HTTP запросом?",
    "answer": "В пути; Как атрибут запроса; В теле запроса; В заголовке запроса...."
  },
  {
    "theme": "Spring",
    "description": "Что такое View? Как спринг выбирает какой view отобразить?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Что такое Model? Как передать ее из контроллера во view?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "В чем разница между аутентификацией и авторизацией?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Как Spring Security работает?",
    "answer": "работа Security основана на servlet-фильтрах.Сначала запрос попадает в DelegatingFilterProxy, откуда он пересылается в цепочку фильтров FilterChainProxy."
  },
  {
    "theme": "Spring",
    "description": "Основные объекты, участвующие в Spring Security",
    "answer": "SecurityContextHolder — содержит и предоставляет доступ к SecurityContext в приложении. SecurityContext — дефолтная реализация Spring Security содержащая объект Authentication. Authentication — предоставляет токен для запроса аутентификации или для принципала, который прошел аутентификацию. Также содержит список полномочий, к которым получил доступ принципал. GrantedAuthority — содержит полномочия выданные прошедшему проверку принципалу. UserDetails — содержит информацию о пользователе: пароль, логин, полномочия. Эта информация используется для создания объекта Authentication после удачной аутентификации. UserDetailsService — этот сервис извлекает информацию о пользователе из хранилища(память программы, бд, и т.п.) и кладет ее в UserDetails."
  },
  {
    "theme": "Spring",
    "description": "Для чего используется аннотация @RolesAllowed?",
    "answer": "@RolesAllowed позволяет настроить доступ к методам(например, в классе-контроллере) с помощью ролей."
  },
  {
    "theme": "Spring",
    "description": "Чем Spring отличается от Spring Boot?",
    "answer": "Spring Boot — это набор уже настроенных модулей которые работают в Spring Framework и упрощают конфигурирование Spring приложения."
  },
  {
    "theme": "Spring",
    "description": "Что делает @EnableAutoConfiguration. Какие похожие аннотации вы знаете? Как работают аннотации @Enable...",
    "answer": "Она позволяет использовать автоконфигурацию."
  },
  {
    "theme": "Spring",
    "description": "Как Spring Boot сканирует компоненты? Когда компоненты могут не попасть под сканирование, где они должны находиться и как отмечены чтобы спринг их просканировал?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Что такое стартер? Как создать стартер?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Для чего используется аннотация @Transactional? Какие у нее есть параметры?",
    "answer": "Propagation: REQUIRED - выполняется во внешней транзакции. Если ее нет - будет создана новая. SUPPORTS - выполняется во внешней транзакции если она есть, если ее нет - выполняется без транзакции. MANDATORY - выполняется во внешней транзакции если она есть, если ее нет - выбросится исключение. NEVER - если есть внешняя активная транзакция - выбросится исключение. NOT_SUPPORTED - если есть внешняя транзакция - она будет прервана и метод выполнится без транзакции. REQUIRES_NEW - если есть внешняя транзакция - будет создана новая отдельная. NESTED - будет создана вложенная транзакция. Isolation: READ_UNCOMMITTED - низший уровень изоляции. READ_COMMITTED - спасает от грязного чтения - используется ПО УМОЛЧАНИЮ. REPEATABLE_READ -  от грязного чтения, неповторяемого чтения. SERIALIZABLE  - высшая степень изоляции"
  },
  {
    "theme": "Spring",
    "description": "Что такое коммит транзакции? В каких случаях происходит RollBack? Если есть несколько вложенных транзакций и в самой последней возникнет исключение - откатятся все транзакции или часть?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Для чего используется аннотация @Async? как настроить пул потоков, в котором будет выполняться метод, помеченный этой аннотацией?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Разница между BeanFactory and ApplicationContext",
    "answer": "BeanFactory loads beans on-demand, while ApplicationContext loads all beans at startup. The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup. The ApplicationContext comes with advanced features, including several that are geared towards enterprise applications, while the BeanFactory comes with only basic features. Therefore, it's generally recommended to use the ApplicationContext, and we should use BeanFactory only when memory consumption is critical."
  },
  {
    "theme": "Spring",
    "description": "Скоупы бинов. Отличия между бинами различных скоупов",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "Как создаются бины, сразу или лениво? Как изменить это поведение?",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "AOP, основные понятия, как работает, какие виды прокси бывают в спринге, что такое поинкат, адвайс",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "MVC, DispatcherServlet",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "CORS",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "jwt",
    "answer": ""
  },
  {
    "theme": "Spring",
    "description": "JDBCTemplate",
    "answer": "The JDBC template is the main API through which we'll access most of the functionality that we're interested in:\n\ncreation and closing of connections\nrunning statements and stored procedure calls\niterating over the ResultSet and returning results"
  },

  {
    "theme": "REST",
    "description": "Что такое REST. В чем отличия HATEOAS от REST? На основании какого протокола работает REST?",
    "answer": ""
  },
  {
    "theme": "REST",
    "description": "Какие есть методы у HTTP протокола? Какие из этих методов безопасные? Что такое идемпотентность? Какие методы идемпотентные? Когда используется метод PUT а когда PATCH?",
    "answer": ""
  },
  {
    "theme": "REST",
    "description": "Для чего предназначены HTTP статусы? Что означают статусы: 100, 201, 301, 500. Каким статусом отвечать клиенту если у него не хватает прав на доступ к рест-методу?",
    "answer": "100 Continue («продолжай»). 201 Created («создано»). 301 Moved Permanently («перемещено навсегда»). 500 Internal Server Error («внутренняя ошибка сервера»). 403 Forbidden («запрещено (не уполномочен)»)"
  },
  {
    "theme": "REST",
    "description": "С какими запросами можно передать тело?",
    "answer": ""
  },
  {
    "theme": "REST",
    "description": "Что такое RestTemplate? Как настроить таймаут запроса, попытки повторного запроса?",
    "answer": ""
  },
  {
    "theme": "REST",
    "description": "Как можно протестировать REST-эндпоинты в JUnit?",
    "answer": "С помощью MockMVC пожно имитирвать запросы к контроллеру"
  },
  {
    "theme": "REST",
    "description": "На фронте есть таблица с товарами, в которой нужно показывать товары постранично. Также можно создавать, изменять, удалять товары. Опишите контракт REST-API",
    "answer": ""
  },
  {
    "theme": "REST",
    "description": "Для чего в проектах существует файл api.yaml? Как можно описывать документацию для REST контроллеров?",
    "answer": ""
  },
  {
    "theme": "REST",
    "description": "Все данные в эндпоинты контроллеров поступают в виде строк - как Спринг понимает что это за данные и преобразует их в нужный тип?. Как можно написать свой конвертер для REST?",
    "answer": "С помощью конвертеров, которые находятся в контексте и ообрабатывают запросы. Можно писать свои кастомные конвертеры, для этого нужно всего лишь имплементировать  Converter и реализовать метод convert()"
  },

  {
    "theme": "DataBase",
    "description": "Что такое нормализация баз данных? Перечислите основные нормальные формы. В чем риски ненормализованных баз данных?",
    "answer": "Нормализация -  устранение избыточности данных в БД (исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении, редактировании и удалении кортежей(строк таблицы)). Первая нормальная форма - все атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице. Вторая нормальная форма -  находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа(ПК). Третья нормальная форма - находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа (требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы). Нормальная форма Бойса-Кодда (НФБК) (частная форма третьей нормальной формы) , четвертая, пятая ....."
  },
  {
    "theme": "DataBase",
    "description": "Виды Join",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "В чем отличие JOIN от UNION (UNION ALL)?",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "Когда используется WHERE а когда HAVING?",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "Что такое view? Какие виды view бывают? В чем отличие обычного view от materialized?",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "Что такое индекс? Как индексы ускоряют исполнение запросов? Какие индексы бывают?  Когда индексы могут ухудшить производительность?",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "Что такое перичный ключ? Внешний ключ? Как можно связать таблицы по этим ключам?",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "Есть таблица покупателей. С таблицей покупателей связана таблица заказов. У каждого заказа есть цена и дата заказа. Как вывести только названия всех заказов, упорядоченные по цене в обратном порядке? Как вывести количество заказов каждого покупателя? Как вывести таблицу, в которой будет каждый покупатель и его самый последний заказ?",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "Приведите пример запроса, с помощью которого можно добавить новую колонку в таблицу",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "В чем разница между командами  TRUNCATE, DELETE, DROP",
    "answer": ""
  },
  {
    "theme": "DataBase",
    "description": "Что такое хранимая процедура? Как ее создать? как вызвать?",
    "answer": ""
  },

  {
    "theme": "Patterns",
    "description": "Принципы ООП, кратко опишите каждый из них",
    "answer": "Абстракция, инкапсуляция, полиморфизм, наследование"
  },
  {
    "theme": "Patterns",
    "description": "Что такое SOLID? Расшифруйте и опишите каждую букву.",
    "answer": ""
  },
  {
    "theme": "Patterns",
    "description": "Что такое паттерны проектирования? Зачем они нужны? Какие приходилось использовать?",
    "answer": ""
  },
  {
    "theme": "Patterns",
    "description": "Шаблонный метод, Стратегия, декоратор, билдер",
    "answer": ""
  },
  {
    "theme": "Patterns",
    "description": "Следуете ли вы YAGNI, KISS, DRY?",
    "answer": "(«You aren't gonna need it»; — «Вам это не понадобится». KISS («Keep it simple, stupid» — «Делай проще, тупица»). Don't repeat yourself (DRY; «не повторяйся») "
  },
  {
    "theme": "Patterns",

    "description": "На какие группы делятся паттерны?",
    "answer": "Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей. Структурные паттерны показывают различные способы построения связей между объектами. Поведенческие паттерны заботятся об эффективной коммуникации между объектами."
  },
  {
    "theme": "Patterns",
    "description": "Что такое ACID? Для чего это применяется?",
    "answer": ""
  },
  {
    "theme": "Patterns",
    "description": "Что такое TDD? Что такое DDD?",
    "answer": "TDD, test-driven development или разработка через тестирование. DDD - Проблемно-ориентированное проектирование основано на подходе, при котором классы моделируются на основе реальных бизнес процессов."
  },
  {
    "theme": "Patterns",
    "description": "CAP",
    "answer": ""
  },
  {
    "theme": "Brokkers",
    "description": "Очереди сообщений, с какими приходилось работать. Что такое Exchange в RabbitMq\nDocker - в чем отличие образа от контейнера, какой командой можно запустить контейнер? Что такое docker-compose? Как запустить все контейнеры, описанные в docker-compose файле? Как пробросить порт контейнера на порт на локальной машине?",
    "answer": ""
  }

]